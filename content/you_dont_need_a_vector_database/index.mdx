---
title: "You (Probably) Don’t Need an Embedding Database"
description: "Vector Databases are in vogue, but do you really need one to support your AI powered Search?"
image: "../../public/blogs/omgjjd_database_blog-2.png"
publishedAt: "January 30, 2024"
updatedAt: "February 2, 2024"
author: "Justin Donaldson"
isPublished: true
tags:
- Embedding
- Search
- Open Source
---

## Vector Databases are in vogue, but do you really need one to support your AI powered Search?

If you’ve been paying attention to the recent advances in Large Language Models (LLM), you’ve noticed that a whole new crop of startups emerged to provide search over embeddings.

<Image
  src="/blogs/vectoDatabaseBrands.png"
  width="718"
  height="404"
  alt="vectoDatabaseBrands"
  sizes="100vw"
/>

Search over embeddings is a very different process than search over a database of documents. Embedding search uses a vector space representation of an image or document that has been created by a corresponding model, rather than an inverted index of terms and documents. Search in a vector space is typically handled with nearest neighbor search, which returns the embeddings of the closest records to the target record. This technique is much more intensive to calculate than a simple inverted index lookup, and accordingly databases need to make trade offs for precision/recall in order to provide reasonable performance over large sets of data.

### Embedding Databases for Smaller Datasets

Here at Hushh we were suprised to realize that there wasn’t a good option for smaller/portable embeddings for databases. Many modeling tasks rely on smaller and more domain-specific datasets to perform domain-specific tasks. For instance, image recognition models might need to index the products of a given storefront. There may be many thousand products, but often not the millions of products that would necessitate a standalone database. Furthermore, a standalone database would need to be running at all times, incurring a large one-time cost for any sort of embedding search functionality.

If one doesn’t have a lot of data, and doesn’t want to pay the maintenance fee on hosted embedding search, using an embedding search database is costly overkill, but what are the options?

Many embedding databases and models use python, so accordingly, the embeddings can be exported in the python pickle format. However, the pickle format is unsafe, making it a risky bet for production systems.

JSON formats can also be used for pickling data, but JSON requires all of the embedding data to be decoded and loaded into memory. This process can take a significant amount of time, making it costly to load/unload embedding datasets on the fly.

Messagepack is another solid option, optimized for speed and portability. Originally, this was the format that we were likely to use. However, in the back of our minds we wondered, can we make it even faster?

## Introducing The Hushh Catalog Format
We introduce the Hushh Catalog Format (HCF), a file format that is optimized for speedy (and lazy) loading of embeddings from disk.

To understand the performance benefits of the HCF format, we’ll use this fashion dataset comprising ~44K product images, representative of the fashion offerings of a mid-to-large size department store.

We’ll also take figures and data from this data science notebook that contains the result of the analysis.

React, developed by Facebook (now Meta), is a flexible library for building user interfaces. It focuses on the view layer, providing a simple and efficient way to create interactive components.

### Comparisons
For the purposes of comparison, we’ll generate embedding vectors in three different formats:

- **JSON**: A popular option for web development due to it being human-readable
- **Msgpack**: A schema-less binary format that is a good option for smaller/faster serialization
- **Hushh Catalog Format**: A format with a schema designed especially for storing product information and metadata.

## File Size
<div
  style={{
    display: 'flex', 
    justifyContent: 'center', 
    alignItems: 'center', 
    minHeight: '50vh', 
  }}
>
  <Image
    src="/blogs/fileSizeVector.png"
    width={518}
    height={304}
    alt="Image"
    sizes="80vw"
  />
</div>
